# -*- python -*-
# Copyright (C) 2007, Levin Du.
# Author:  Levin Du <zsdjw@21cn.com>
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANT; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public LIcense for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, 59 Temple
# Place - Suite 330, Boston, MA 02111-1307, USA.

import os
import stat
import sys, glob
import time
import json
from SCons.Action import ActionFactory
from xml.dom.minidom import parse
from syspicker.pickup import Picker
Import('env', 'mi_config', 'MiPkgMaker', 'PkgMaker', 'getSudoSh')

picker = Picker(use_bash=True, tmpdir=mi_config.tmpdir)

cachefpath1 = '_rootfiledepcache.json'
cachejson1 = json.loads('{}')
cacheb1 = False
def initcache(tmpdir=''):
    global cacheb1, cachejson1, cachefpath1
    if tmpdir:
        cachefpath1 = os.path.join(tmpdir, cachefpath1)
    if os.path.exists(cachefpath1):
        print 'loading cache...'
        t = time.time()
        with open(cachefpath1, 'rt') as fp:
            cachejson1 = json.load(fp)
        print 'load cache done ', time.time() - t
    else:
        cachejson1 = json.loads('{}')
    cacheb1 = True
    
import atexit

def all_done():
    global cacheb1, cachejson1, cachefpath1
    if cacheb1:
        print 'saving cache...'
        t = time.time()
        with open(cachefpath1, 'wt') as fp:
            json.dump(cachejson1, fp, indent=4)
        print 'saving cache done ', time.time() - t

atexit.register(all_done)

initcache(mi_config.tmpdir)

class FileNotExists(Exception):
    pass

def line_split(lines):
    result = []
    for line in lines.split('\n'):
        line = line.strip()
        if line and line[0] != '#':
            result.append(line)
    return result

def get_node_value(node, name):
    value = ''
    for subnode in node.childNodes:
        if subnode.nodeType == subnode.ELEMENT_NODE \
           and subnode.tagName == name:
            value = ''.join([t.data for t in subnode.childNodes \
                             if t.nodeType == t.TEXT_NODE])
    return line_split(value)

class RootBuildNode(PkgMaker.BaseMaker):
    def __init__(self, mod, env):
        self.env = env
        self.source_list = source_list = []
        self.build_cmds = cmds = []

        source_list.append(mod + '.xml')
        try:
            rootdoc = parse(source_list[-1])
        except:
            print 'Parser mod %s.xml failed!' % mod
            raise

        # init
        cmds.extend(['rm -rf $BUILD',
                     'mkdir -p $BUILD'])
        inst_list = []
        pre_list = []
        post_list = []
        tarpkgs = []

        for pkgnode in rootdoc.getElementsByTagName('package'):
            pkgfiles_orig = get_node_value(pkgnode, 'files')
            if pkgfiles_orig:
                pkglist = []
                #pkgfiles = self.path_prefix('$source_list_pkg', pkgfiles_orig)
                for pkgfiles in pkgfiles_orig:
                    if pkgfiles[0] == '#':
                        continue
                    
                    if pkgfiles[0] not in ('@', '+'):
                        pkgfiles = glob.glob(pkgfiles)
                        
                    for pkgfile in pkgfiles:
                        pkg_path = self.search_file(pkgfile, ['$source_prefix_pkg', '$source_prefix'])
                        if pkg_path:
                            pkglist.append(pkg_path)
                        else:
                            print "Can not find the package %s" % pkgfile
                            sys.exit(1)

                tarpkgs.extend(pkglist)
                
            install_list = []
            for instfiles in get_node_value(pkgnode, 'install'):
                if instfiles[0] == '#':
                    continue
                    
                if instfiles[0] not in ('@', '+'):
                    instfiles = glob.glob(instfiles)
                else:
                    instfiles = [instfiles, ]

                install_list.extend(instfiles)
                
            inst_list.extend(install_list)
            
            pre_list.extend(get_node_value(pkgnode, 'pre_action'))
            post_list.extend(get_node_value(pkgnode, 'post_action'))

        # extract
        tarpkgs = list(set(tarpkgs))
        cmds.extend(self.get_extract_cmd(tarpkgs, '$build_prefix'))

        # pre_action
        cmds.extend(pre_list)
        # install
        picker_inst_list = []
        old_inst_list = []
        for fpath in inst_list:
            if fpath.startswith('/'):
                if not os.path.exists(fpath):
                    raise FileNotExists(fpath)
                picker_inst_list.append(fpath)
            elif fpath[:2] in ('+/', '@/'):
                if not os.path.exists(fpath[1:]):
                    raise FileNotExists(fpath)
                picker_inst_list.append(fpath)
            else:
                old_inst_list.append(fpath)
        # picker files install
        def get_recursive_flist(dpath):
            flist = []
            for root, dirs, files in os.walk(top=dpath, topdown=True):
                for f in files:
                    flist.append(os.path.join(root, f))
            return flist
        
        addlist = []
        for f in picker_inst_list:
            if f[0] == '+':
                addlist.append(f[1:])
            elif f[0] == '@':
                addlist.extend(get_recursive_flist(f[1:]))
            else:
                addlist.append(f)
                
        _addlist = filter(lambda p: os.path.splitext(p)[1] not in ('.pyc', '.xml'), addlist)

        newfiles0 = []
        for addfile in _addlist:
            if cachejson1.has_key(addfile):
                #print 'hit cache in root file dep %s' % addfile
                newfiles = cachejson1[addfile]
            else:
                newfiles = picker.AddFiles([addfile,])
                cachejson1[addfile] = newfiles
            newfiles0.extend(newfiles)
        newfiles0.extend(addlist)
        cmds.append(pcmd_decorator(lambda : picker.copyFiles(newfiles0, env.subst('$ROOT'))))
        
        # old files install mode
        for f in old_inst_list:
            if f[0] == '+':             # mkdir only
                f = f[1:]
                cmds.extend(['mkdir -p $ROOT/%s' % f])

            elif f[0] == '@':           # recursive
                f = f[1:]
                cmds.extend(['mkdir -p $ROOT/%s' % os.path.dirname(f),
                             'cp -a $BUILD/%s $ROOT/%s/' % (f, os.path.dirname(f))])
            else:
                cmds.extend(['mkdir -p $ROOT/%s' % os.path.dirname(f),
                             'cp -dp $BUILD/%s $ROOT/%s/' % (f, os.path.dirname(f))])

        # post_action
        cmds.extend(post_list)

    def search_file(self, filename, pathes):
        for p in pathes:
            f = os.path.join(p, filename)
            f = self.env.subst(f)
            files = glob.glob(f)
            if files and os.access(files[0], os.R_OK):
                return files[0]
            
def pcmd_decorator(cmd_func):
    def _exefunc(*args, **kw):
        kw['cmd_func'] = cmd_func
        return pcmd(*args, **kw)
    return _exefunc

def pcmd(env, target, source, cmd_func=None):
    if cmd_func:
        cmd_func()
    
class RootPkgMaker(MiPkgMaker):
    source_prefix = '#bindir/root_ext'
    source_prefix_pkg = '#bindir/root_pkg'

    build_root =  mi_config.tmpdir
    build_prefix = '$build_root/${package}.tmp'
    install_prefix = '$build_root/${package}'
    pack_prefix = '#bindir'

    build_cmds = []
    mods = []
    global_post_cmds = []

    def initenv(self):
        MiPkgMaker.initenv(self)
        env = self.env
        env['ROOT'] = self.get_abspath(env['install_prefix'])
        env['BUILD'] = self.get_abspath(env['build_prefix'])
        env['source_prefix_pkg'] = self.get_abspath(self.source_prefix_pkg)

        self.parse_def_mods()

    def parse_def_mods(self):
        raise NotImplementedError()

    def build(self):
        env = self.env
        for mod in self.mods:
            self.build_cmds.extend(mod.build_cmds)
            self.source_list.extend(mod.source_list)
        env.Alias(self.alias,
                  env.Command('$pack_prefix/$package_bin',
                              self.source_list,
                              [getSudoSh('rm -rf $ROOT'),
                               'mkdir -p $ROOT'] +
                              self.build_cmds +
                              self.global_post_cmds +
#                               [getSudoSh('chown -R root $ROOT')] +
#                               [getSudoSh('chgrp -R root $ROOT')] +
                              [getSudoSh(self.fetch_pack_cmds()[0])] +
                              ['rm -rf $BUILD']))

    def make(self):
        self.initenv()
        self.build()

class RootMagic64Maker(RootPkgMaker):
    alias = 'root.step1.mgc30_64'
    package = 'root.step1.mgc30_64'
    package_bin = '${package}.tar.gz'

#     global_post_cmds = [PkgMaker.SearchExecAction('$ROOT',
#                                                   ['usr/lib/xorg/modules', 'lib/modules'],
#                                                   'strip %s')]
    global_post_cmds = []

    def parse_def_mods(self):
        mods = self.mods
        for mod_src in ['filesystem',
                        'busybox',
                        'bash',
                        'systemd',
                        'python',
                        'xorg',
                        'gtk2',
                        'parted',
                        'rpm',
                        'mkfs',
#                         'grub',
#                         'trace',
#                         'post_scripts',
                        ]:
            mods.append(RootBuildNode(mod_src, self.env))

pkg = RootMagic64Maker(env)
pkg.make()
env.Alias('root.step1', env.Command('#bindir/root.step1.tar.gz', 'root.step1.mgc30_64',
        '[ -L $TARGET ] && rm $TARGET; ln -sv %s.tar.gz $TARGET' % pkg.package))
env.Alias('rootfs', 'root.step1')

